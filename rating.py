import nltk
import re
import pprint

import indexer
from csv_handling import load_tweet_csv
from normalizer import Normalizer
from nltk.corpus import wordnet
from tweet import Tweet


class Rater:
    _future_keywords = set([item for sublist in
                            [word.lemma_names() for word in wordnet.synsets("tomorrow")]
                            + [word.lemma_names() for word in wordnet.synsets("future")]
                            for item in sublist])
    _present_keywords = set([item for sublist in
                             [word.lemma_names() for word in wordnet.synsets("today")]
                             for item in sublist])
    _past_keywords = set([item for sublist in
                          [word.lemma_names() for word in wordnet.synsets("yesterday")]
                          + [word.lemma_names() for word in wordnet.synsets("past")]
                          for item in sublist])
    _kind_keywords = {
        "k1": "clouds",
        "k2": "cold",
        "k3": "dry",
        "k4": "hot",
        "k5": "humid",
        "k6": "hurricane",
        "k8": "ice",
        "k10": "rain",
        "k11": "snow",
        "k12": "storms",
        "k13": "sun",
        "k14": "tornado",
        "k15": "wind",
    }
    _kind_synonymes = dict()

    @staticmethod
    # type: (str) -> dict
    def determine_tense_input(text):
        tokens = Normalizer.tokenize(text)
        tagged = nltk.pos_tag(tokens)

        tense = {
            "future": 0,
            "present": 0,
            "past": 0,
        }
        for word in tagged:
            if word[1] == "MD" or word[0] in Rater._future_keywords:
                tense["future"] += 1
            elif word[1] in ["VBP", "VBZ", "VBG"] or word[0] in Rater._present_keywords:
                tense["present"] += 1
            elif word[1] in ["VBD", "VBN"] or word[0] in Rater._past_keywords:
                tense["past"] += 1
        return tense

    @staticmethod
    def post_tense(tweet):
        # type: (Tweet) -> Tweet
        tense = Rater.determine_tense_input(tweet.get_tweet())
        tweet["w1"] *= (tense["present"] / 2 + 1)
        tweet["w2"] *= (tense["future"] / 2 + 1)
        tweet["w4"] *= (tense["past"] / 2 + 1)
        if tense["present"] == 0 and tense["future"] == 0 and tense["past"] == 0:
            tweet["w3"] = 1
        return tweet

    @staticmethod
    def weather_tag_posts(tweet):
        # type: (Tweet) -> Tweet
        """
        Rates an autogenerated tweet.
        Problems:
            Wind:
            #WEATHER:  7:53 am : 60.0F. Feels 60F. 29.82% Humidity. 4.6MPH Northwest Wind. 	k15: 1.0
            vs.
            #WEATHER: 12:53 pm : 84.0F. Feels F. 29.90% Humidity. 11.5MPH South Wind. 	k15: 0.382
            --> Wind is two times stronger but just a third in the rating...
            Other informations are also very inconsistent, the last 7 entries for example:
                                                                                            Cold / Hot / humid
            #WEATHER: 5:53 am E: 66.0F. Feels F. 29.99% Humidity. 0.0MPH North Wind. 	    [0.206, 0.0, 0.0]
            #WEATHER:  7:53 am : 60.0F. Feels 60F. 29.82% Humidity. 4.6MPH Northwest Wind. 	[0.0, 0.0, 1.0]
            #WEATHER: 1:53 am E: 49.0F. Feels F. 30.09% Humidity. 3.5MPH North Wind. 	    [0.613, 0.0, 0.181]
            #WEATHER: 4:51 pm E: 60.0F. Feels 59F. 29.85% Humidity. 8.1MPH Southwest Wind. 	[0.207, 0.0, 0.421]
            #WEATHER: 8:54 pm E: 66.0F. Feels F. 29.91% Humidity. 0.0MPH North Wind. 	    [0.0, 0.0, 0.796]
            #WEATHER: 11:53 pm : 59.0F. Feels 58F. 30.07% Humidity. 5.8MPH South Wind. 	    [0.0, 0.0, 0.616]
            #WEATHER:  8:53 pm : 70.0F. Feels F. 29.84% Humidity. 3.5MPH East Wind. 	    [0.0, 0.0, 0.406]
        :param tweet: the tweet
        :returns an tweet if matching tweet or None
        """
        match = re.findall(
            r'#WEATHER:\s+\d{1,2}:\d{1,2} .m\s*\w?:\s(\d{1,}\.\d{1,}F)\.\sFeels\s(\d+)?F\.\s(\d{1,}\.\d{1,2})?%\sHumidity\.\s(\d{1,}\.\d{1,})?MPH\s(\w+)?\sWind\.',
            tweet.get_tweet())
        if not match:
            return None
        return Tweet({'id': tweet.get_id(),
                      'k1': 0.00024505146476642915,
                      'k10': 0.0011991290577988915,
                      'k11': 0.00044734758511480596,
                      'k12': 0.0005459224069675377,
                      'k13': 0.027455265241488547,
                      'k14': 6.571654790182106e-05,
                      'k15': 0.5327573238321458,
                      'k2': 0.0802165479018211,
                      'k3': 0.02191488519398259,
                      'k4': 0.08757403008709407,
                      'k5': 0.4889077593032456,
                      'k6': 6.690419635787807e-05,
                      'k7': 0.22739271575613618,
                      'k8': 0.00022684085510688834,
                      'k9': 0.17864172604908912,
                      's1': 0.002547901821060967,
                      's2': 0.0005914489311163895,
                      's3': 0.9850958036421216,
                      's4': 0.006712589073634207,
                      's5': 0.005052256532066507,
                      'tweet': tweet.get_tweet(),
                      'w1': 0.9251963578780696,
                      'w2': 0.027378463974663505,
                      'w3': 0.04577870150435465,
                      'w4': 0.0016444972288202691})

    @staticmethod
    def rate_kind(tweet):
        # type: (Tweet) -> Tweet
        """Rates the kind values, this can lead to k values > 1, therefore normalize would be appropriate"""
        if len(Rater._kind_synonymes) == 0:
            for key, value in Rater._kind_keywords.iteritems():
                Rater._kind_synonymes[key] = set([word for word in wordnet.synsets(value)[0].lemma_names()])

        for token in Normalizer.tokenize(tweet.get_tweet()):
            for key, keywords in Rater._kind_synonymes.iteritems():
                for keyword in keywords:
                    if nltk.edit_distance(token, keyword) < 2:
                        if key not in tweet:
                            tweet[key] = 0
                        tweet[key] += 0.5
        return tweet


def analyse_weather_tweets():
    plain_tweets = load_tweet_csv(indexer.TRAININGS_DATA_FILE)
    all_tweets = dict()
    for tweet in plain_tweets:
        match_b = re.findall(
            r'#WEATHER:\s+\d{1,2}:\d{1,2} .m\s*\w?:\s(\d{1,}\.\d{1,}F)\.\sFeels\s(\d+)?F\.\s(\d{1,}\.\d{1,2})?%\sHumidity\.\s(\d{1,}\.\d{1,})?MPH\s(\w+)?\sWind\.',
            tweet.get_tweet())
        if match_b:
            print tweet.get_tweet(), "\t", [tweet[k] for k in ["k2", "k4", "k5"]]
            all_tweets[str(tweet.get_id())] = tweet


if __name__ == '__main__':
    print Rater.rate_kind(Tweet({
        "tweet": "With the snow forecast for Tahoe this weekend, maybe the @mention riders need to bust out the 'Cross bikes :) @mention"
    }))

    # future
    print Rater.determine_tense_input(
        "With the snow forecast for Tahoe this weekend, maybe the @mention riders need to bust out the 'Cross bikes :) @mention")
    print Rater.determine_tense_input(
        "...CRITICAL FIRE WEATHER CONDITIONS EXPECTED FRIDAY AFTERNOON... .RED FLAG WARNING CONDITIONS ARE POSSIBLE THIS AFTERNO {link}")

    # present
    print Rater.determine_tense_input(
        "Father. Son. Holy ghost. Amen... hope I come out alive =) (this is the Hot~ness) Namaste*!~ {link}")
    print Rater.determine_tense_input(
        "Can already tell it's going to be a tough scoring day. It's as windy right now as it was yesterday afternoon.")
    # past
    print Rater.determine_tense_input(
        "It was 102 degrees yesterday. I am not ready for this heat. San Diego sounds good right about now")
    print Rater.determine_tense_input(
        "Currently working on Melissa and Josh's engagement photos from this past rainy weekend. Can't wait to share.")
